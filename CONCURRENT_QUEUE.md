# 任务并发队列系统

## 功能说明

本系统实现了任务并发控制，可以限制同时处理的任务数量，超出限制的任务会自动排队等待。

## 配置方法

### 1. 修改配置文件

编辑项目根目录的 `config.json` 文件：

```json
{
  "server": {
    "port": 3000,
    "maxConcurrentTasks": 2
  }
}
```

**配置项说明：**
- `port`: 服务器监听端口（默认 3000）
- `maxConcurrentTasks`: 最大并发任务数（默认 2）

### 2. 推荐配置

根据您的机器性能选择合适的并发数：

| 机器配置 | 推荐并发数 | 说明 |
|---------|-----------|------|
| 低配置（4核8G以下） | 1-2 | 避免系统卡顿 |
| 中配置（4核8G-8核16G） | 2-3 | 平衡性能和稳定性 |
| 高配置（8核16G以上） | 3-5 | 充分利用资源 |
| 服务器（16核32G以上） | 5-10 | 最大化处理效率 |

⚠️ **注意**：
- 并发数过高可能导致内存溢出或系统卡顿
- 建议从较小的值开始测试，逐步调整
- 每个任务处理时会占用 CPU 和内存资源

## 工作原理

### 1. 任务队列管理

```
上传任务 → 加入队列 → 检查并发限制
                         ↓
                    是否达到最大并发？
                    ↙           ↘
                 是              否
                 ↓              ↓
            保持排队         立即开始处理
                 ↓              ↓
            等待位置         任务执行中
                 ↓              ↓
            自动启动 ←─────── 任务完成
```

### 2. 状态流转

- **queue（排队中）**: 任务在队列中等待
- **processing（处理中）**: 任务正在执行
- **completed（已完成）**: 任务成功完成
- **failed（失败）**: 任务执行失败
- **cancelled（已取消）**: 任务被用户取消

### 3. 自动调度

- 任务完成/失败/取消后，自动启动下一个排队任务
- 取消队列中的任务，立即从队列移除
- 取消处理中的任务，标记为已取消并触发下一个任务

## 前端显示

### 1. 统计卡片

- **并发处理**: 显示当前处理数/最大并发数（如：2/3）
  - 未满：蓝紫色渐变边框
  - 已满：橙色边框 + 脉冲动画

- **排队中**: 显示等待处理的任务数
- **处理中**: 显示正在处理的任务数
- **已完成**: 显示完成的任务数
- **失败**: 显示失败的任务数

### 2. 任务列表

每个任务显示：
- 任务名称和类型（📁 文件夹 / 📦 ZIP）
- 当前状态（排队中/处理中/已完成/失败/已取消）
- 处理进度（处理中时显示）
- 操作按钮（取消/下载/删除）

## API 接口

### 获取队列状态

```http
GET /api/queue/status
```

**响应：**
```json
{
  "success": true,
  "maxConcurrent": 2,
  "processing": 2,
  "waiting": 3,
  "queueItems": [
    {
      "taskId": "1234567890",
      "taskName": "hotupdate"
    }
  ]
}
```

### 获取所有任务

```http
GET /api/tasks
```

**响应：**
```json
{
  "success": true,
  "tasks": [...],
  "queue": {
    "maxConcurrent": 2,
    "processing": 1,
    "waiting": 2
  }
}
```

## 使用示例

### 场景 1：批量上传任务

1. 拖入 5 个文件夹
2. 前 2 个（maxConcurrentTasks=2）立即开始处理
3. 后 3 个进入队列排队
4. 当前 2 个完成后，自动处理后 3 个

**控制台输出：**
```
📤 接收到任务
📊 当前状态: 处理中 2/2, 队列中 3
⏸️  达到最大并发数 2，任务排队中...
✅ 任务完成
🔄 任务结束，尝试启动下一个排队任务...
▶️  开始处理排队任务 (剩余队列: 2)
```

### 场景 2：取消任务

**取消处理中的任务：**
1. 用户点击"⛔ 取消任务"
2. 任务标记为 cancelled
3. 自动启动下一个排队任务

**取消排队中的任务：**
1. 用户点击"⛔ 取消任务"
2. 从队列中移除
3. 立即尝试启动下一个任务

## 性能优化建议

1. **合理设置并发数**
   - 观察系统资源使用情况
   - CPU 使用率应保持在 70% 以下
   - 内存使用率应保持在 80% 以下

2. **任务大小控制**
   - 单个任务建议不超过 1GB
   - 大量小文件比少量大文件处理更慢

3. **监控和调整**
   - 实时查看"并发处理"状态
   - 根据处理速度调整并发数
   - 定期清理已完成的任务

## 故障排查

### 任务一直排队不处理

**可能原因：**
- 已有任务达到并发上限
- 任务处理异常未释放资源

**解决方法：**
1. 检查是否有任务卡住
2. 取消异常任务
3. 重启服务器

### 任务处理失败

**可能原因：**
- 文件格式不正确
- 磁盘空间不足
- 内存溢出

**解决方法：**
1. 检查错误信息
2. 降低并发数
3. 清理临时文件

### 系统卡顿

**可能原因：**
- 并发数设置过高
- 任务文件过大

**解决方法：**
1. 立即降低 `maxConcurrentTasks`
2. 取消部分任务
3. 重启服务器

## 更新日志

- **v1.0** - 初始版本，支持基本任务处理
- **v2.0** - 添加并发队列系统
  - 可配置的最大并发数
  - 自动任务调度
  - 队列状态实时显示
  - 取消任务优化

## 技术细节

### 实现原理

```typescript
// 任务队列结构
interface TaskQueueItem {
    taskId: string;
    files: Express.Multer.File[];
    isZip: boolean;
    filePathMap?: Map<string, string>;
}

// 队列管理
const taskQueue: TaskQueueItem[] = [];

// 检查是否可以开始新任务
function canStartNewTask(): boolean {
    return getProcessingTaskCount() < CONFIG.MAX_CONCURRENT_TASKS;
}

// 尝试启动下一个任务
function tryStartNextTask() {
    if (taskQueue.length === 0 || !canStartNewTask()) {
        return;
    }
    const nextItem = taskQueue.shift();
    processTask(...);
}
```

### 并发控制

1. 上传时检查并发限制
2. 达到限制时加入队列
3. 任务结束时触发下一个
4. 取消任务时重新调度

---

**提示**: 修改配置后需要重启服务器才能生效！
