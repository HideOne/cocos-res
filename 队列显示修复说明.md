# 队列显示修复说明

## 问题描述

前端"排队中"统计数据显示不正确，无法准确反映服务器端真实的任务队列状态。

## 问题原因

1. **数据来源不同步**
   - 前端：统计本地 `tasks` 数组中 `status === 'queue'` 的任务
   - 后端：真实的任务队列存储在 `taskQueue` 数组中
   - 两者没有同步机制

2. **状态变化时机**
   - 任务上传后立即加入服务器队列
   - 如果可以处理，状态立即变为 `processing`
   - 前端本地数据无法反映服务器队列的实时变化

## 解决方案

### 1. 添加服务器队列状态存储

```javascript
class TaskManager {
    constructor() {
        this.tasks = [];
        this.taskIdCounter = 1;
        this.serverQueueStatus = null; // 新增：存储服务器队列状态
        this.init();
    }
}
```

### 2. 创建队列状态刷新方法

```javascript
// 刷新队列状态（可被手动调用）
async refreshQueueStatus() {
    try {
        const response = await fetch(httpUrl + '/api/queue/status');
        if (response.ok) {
            const result = await response.json();
            if (result.success) {
                this.updateQueueStatus(result);
            }
        }
    } catch (error) {
        console.debug('获取队列状态失败:', error);
    }
}
```

### 3. 优化统计数据显示

```javascript
updateStats() {
    // 排队中和处理中的数据优先使用服务器数据（如果可用）
    if (this.serverQueueStatus) {
        document.getElementById('queueCount').textContent = this.serverQueueStatus.waiting;
        document.getElementById('processingCount').textContent = this.serverQueueStatus.processing;
    } else {
        // 备用方案：使用本地数据
        document.getElementById('queueCount').textContent = this.getQueueCount();
        document.getElementById('processingCount').textContent = this.getProcessingCount();
    }
    
    // 已完成和失败的数据使用本地统计
    document.getElementById('completedCount').textContent = this.getCompletedCount();
    document.getElementById('failedCount').textContent = this.getFailedCount();
}
```

### 4. 自动和手动触发更新

**自动轮询更新**
- 页面加载后立即获取一次
- 每 2 秒自动刷新一次

**手动触发更新**
- 任务完成时
- 任务取消时
- 任务失败时

## 数据流向

```
服务器端
   ↓
GET /api/queue/status
   ↓
返回: {
  maxConcurrent: 2,
  processing: 2,
  waiting: 3,
  queueItems: [...]
}
   ↓
前端 refreshQueueStatus()
   ↓
updateQueueStatus(result)
   ↓
serverQueueStatus = result
   ↓
updateStats() 使用服务器数据
   ↓
显示: 排队中 3
```

## 显示优先级

| 数据项 | 优先级 | 数据源 |
|--------|--------|--------|
| 排队中 | 1. 服务器数据 | API: /api/queue/status |
|        | 2. 本地数据（备用） | tasks.filter(t => t.status === 'queue') |
| 处理中 | 1. 服务器数据 | API: /api/queue/status |
|        | 2. 本地数据（备用） | tasks.filter(t => t.status === 'processing') |
| 已完成 | 本地数据 | tasks.filter(t => t.status === 'completed') |
| 失败 | 本地数据 | tasks.filter(t => t.status === 'failed') |

## 测试场景

### 场景 1：批量上传任务

1. 上传 5 个文件夹（并发限制为 2）
2. 预期显示：
   - 处理中: 2
   - 排队中: 3
   - 总计: 5

### 场景 2：任务完成

1. 第一个任务完成
2. 预期显示：
   - 处理中: 2 → 2（自动启动队列中的任务）
   - 排队中: 3 → 2
   - 已完成: 0 → 1

### 场景 3：取消队列中的任务

1. 取消排队中的任务
2. 预期显示：
   - 排队中: 3 → 2
   - 已取消: 0 → 1

### 场景 4：取消处理中的任务

1. 取消正在处理的任务
2. 预期显示：
   - 处理中: 2 → 2（自动启动队列中的任务）
   - 排队中: 2 → 1
   - 已取消: 0 → 1

## 技术细节

### API 响应格式

```json
{
  "success": true,
  "maxConcurrent": 2,
  "processing": 2,
  "waiting": 3,
  "queueItems": [
    {
      "taskId": "1234567890",
      "taskName": "hotupdate"
    },
    {
      "taskId": "1234567891",
      "taskName": "resources"
    }
  ]
}
```

### 更新时机

| 触发点 | 方法 | 延迟 |
|--------|------|------|
| 页面加载 | refreshQueueStatus() | 立即 |
| 定时轮询 | refreshQueueStatus() | 每 2 秒 |
| 任务完成 | refreshQueueStatus() | 立即 |
| 任务取消 | refreshQueueStatus() | 立即 |

## 优势

1. ✅ **准确性**: 直接使用服务器数据，100% 准确
2. ✅ **实时性**: 每 2 秒自动更新，关键操作后立即更新
3. ✅ **可靠性**: 有备用方案，服务器不可用时使用本地数据
4. ✅ **响应性**: 任务状态变化时立即反馈到界面
5. ✅ **一致性**: 前后端数据保持同步

## 注意事项

1. 网络延迟可能导致短暂的数据不同步（最多 2 秒）
2. 服务器不可用时会回退到本地数据
3. 本地数据仅作为备用，可能不准确
4. 刷新频率为 2 秒，可根据需要调整

---

**修复日期**: 2026-01-16  
**版本**: v2.1
